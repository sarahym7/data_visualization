---
title: "Visualization"
subtitle: "Part II"
author: "Sarahy Martinez"
date: "2024-10-03"
output: github_document
---

## Look at the weather data 


```{r}
library(tidyverse)
library(patchwork)

```

```{r}
weather_df = 
  rnoaa::meteo_pull_monitors(
    c("USW00094728", "USW00022534", "USS0023B17S"),
    var = c("PRCP", "TMIN", "TMAX"), 
    date_min = "2021-01-01",
    date_max = "2022-12-31") |>
  mutate(
    name = case_match(
      id, 
      "USW00094728" ~ "CentralPark_NY", 
      "USW00022534" ~ "Molokai_HI",
      "USS0023B17S" ~ "Waterhole_WA"),
    tmin = tmin / 10,
    tmax = tmax / 10) |>
  select(name, id, everything())


```

## Remember this plot?

```{r}
weather_df %>% 
  ggplot(aes(x = tmin, y = tmax)) + 
  geom_point(aes(color = name), alpha = .5)  #3 aesthetics defined  tmin, tmax, color 

```

If this were a plot we wanted to share its sufficient but someone might not know whats going on so we will add a text or label.

## Labels 

```{r}

weather_df %>% 
  ggplot(aes(x = tmin, y = tmax)) + 
  geom_point(aes(color = name), alpha = .5)+
  labs(
    title = "Temperature Plot",
    x = "Minimum Daily Temperature (C)",
    y = "Maximum Daily Temperature (C)",
    caption = " Data from the rnoaa package; temperatures in 2017"
  )
```




## Scales 
It gives you a way to control what happens between x= tmin and y=tmax

```{r}

weather_df %>% 
  ggplot(aes(x = tmin, y = tmax)) + 
  geom_point(aes(color = name), alpha = .5)+
  labs(
    title = "Temperature Plot",
    x = "Minimum Daily Temperature (C)",
    y = "Maximum Daily Temperature (C)",
    caption = " Data from the rnoaa package; temperatures in 2017"
  )+
  scale_x_continuous(
    breaks=c(-15, 0 , 15),
    labels = c("-15c", "0", "15")   # need to be same length as breaks, more informative ticks 
  ) +     #categorical or factor use scale_x_discrete, defines breaks
scale_y_continuous(
  trans = "sqrt",   #transform data from linear scatter to sqrt, can also do log 
  position = "right"  # moves table name to the right
)

```



## Look at scale colors 

```{r}
weather_df %>% 
  ggplot(aes(x = tmin, y = tmax)) + 
  geom_point(aes(color = name), alpha = .5)+
  labs(
    title = "Temperature Plot",
    x = "Minimum Daily Temperature (C)",
    y = "Maximum Daily Temperature (C)",
    caption = " Data from the rnoaa package; temperatures in 2017"
  )+
  scale_color_hue(h = c(100,300))   #describes the feature of colors, control over colors 


```


```{r}
weather_df %>% 
  ggplot(aes(x = tmin, y = tmax)) + 
  geom_point(aes(color = name), alpha = .5)+
  labs(
    title = "Temperature Plot",
    x = "Minimum Daily Temperature (C)",
    y = "Maximum Daily Temperature (C)",
    caption = " Data from the rnoaa package; temperatures in 2017"
  )+
  scale_color_hue( name = "Location",
                   h =c(100,300)) #updated from variable "Name" to location 
 

```


scale_color_hue is meh, instead 

```{r}
weather_df %>% 
  ggplot(aes(x = tmin, y = tmax)) + 
  geom_point(aes(color = name), alpha = .5)+
  labs(
    title = "Temperature Plot",
    x = "Minimum Daily Temperature (C)",
    y = "Maximum Daily Temperature (C)",
    caption = " Data from the rnoaa package; temperatures in 2017"
  )+
  viridis:: scale_color_viridis(   # scale has to be discrete and we have to tell it that
    
    name = "Location",
    discrete = TRUE
  )

```


Moving away from things that control specific mappings and not data dependent 

## Themes 

doesn't really depend on anything. Where the caption is absent on the data or AES mapping, deals with overall structure. 
```{r}
weather_df %>% 
  ggplot(aes(x = tmin, y = tmax)) + 
  geom_point(aes(color = name), alpha = .5)+
  labs(
    title = "Temperature Plot",
    x = "Minimum Daily Temperature (C)",
    y = "Maximum Daily Temperature (C)",
    caption = " Data from the rnoaa package; temperatures in 2017"
  )+
  viridis:: scale_color_viridis(   # scale has to be discrete and we have to tell it that
    
    name = "Location",
    discrete = TRUE )+
      theme(legend.position = "bottom")   #moved legend at the bottom , there are other arguments 


```


Suppose we didn't like the background etc. Changing the overall theme

```{r}
weather_df %>% 
  ggplot(aes(x = tmin, y = tmax)) + 
  geom_point(aes(color = name), alpha = .5)+
  labs(
    title = "Temperature Plot",
    x = "Minimum Daily Temperature (C)",
    y = "Maximum Daily Temperature (C)",
    caption = " Data from the rnoaa package; temperatures in 2017"
  )+
  viridis:: scale_color_viridis(   # scale has to be discrete and we have to tell it that
    name = "Location",
    discrete = TRUE )+
      theme_minimal()+
      theme(legend.position = "bottom")
  # mostly used by Jeff, made background white and bold outside , theme_classic no gridlines, ggthemes:: has many other themes, note minimal overrides the location. so have to put after

```

  
## Setting Options 

```{r, eval=FALSE}

library(tidyverse)

knitr:: opts_chunk$set(
  fig.width = 6,
  fig.asp = .6,
  out.width = "90%"
)

theme_set(theme_minimal()+ theme(legend.position = "bottom"))

# theme_set to determine whatever theme I want inside of this document. Now everyplot that I make when I load the tidyverse and update the theme everywhere 

# can also update options 

options(
  
  ggplot2.continuous.colour = "viridis",
  ggplot2.continuous.fill = "viridis"
)

#This will take care of the color arguement for plots and densities.

scale_fill_discrete = scale_fill_viridis_d()    
#all the options will make sure it uses the viridus 

```


# Data args in `geom`

```{r}

central_park_df = 
  weather_df %>% 
  filter(name == "CentralPark_NY")

molokai_df = 
  weather_df %>% 
  filter(name == "Molokai_HI")

ggplot(data = molokai_df, aes(x = date, y = tmax, color = name)) + 
  geom_point()+
geom_line()   #connects the dots 


ggplot(data = molokai_df, aes(x = date, y = tmax, color = name)) + 
  geom_point()+
geom_line(data = central_park_df)

```


If we want to use one whole dataset in geom_point and another in geom_line  we can like below. Don't try to make one geom apply to one subset and another geom. Instead we created two different datasets and then used the data arguement data = central_park to determine which dataset applies to which geometry.  

Use often when you need OR want to display a summary that you have computed from a dataset that is more complicated than the mean and median. Often create a second dataset and then use in the arguement. 

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  